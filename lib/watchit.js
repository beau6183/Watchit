// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, WatchitEmitter, conditionalTimeout, defaults, extend, fs, notifyWhenExists, path, pendingTimeouts, watchit,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  path = require('path');

  defaults = {
    retain: false,
    debounce: false,
    include: false,
    recurse: false,
    persistent: true,
    ignored: null
  };

  watchit = function(target, options, callback) {
    var emitter, fswatcher, ignored, ref, retainTarget, scanTargetDir, unwatchTarget, watchTarget, watchTargetDir, watchTargetFile;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    options = extend({}, defaults, options != null ? options : {});
    ignored = function(file) {
      if (options.ignored) {
        if (typeof options.ignored.test === 'function') {
          return options.ignored.test(file);
        } else {
          return options.ignored(file);
        }
      } else {
        return false;
      }
    };
    emitter = options.emitter = (ref = options.emitter) != null ? ref : new WatchitEmitter(callback);
    if (emitter.targets == null) {
      emitter.targets = {};
    }
    if (emitter.targets[target]) {
      return null;
    }
    fswatcher = null;
    emitter.close = function() {
      return emitter.emit('close', target);
    };
    emitter.on('close', function() {
      return fswatcher != null ? fswatcher.close() : void 0;
    });
    (watchTarget = function() {
      emitter.targets[target] = {};
      return fs.stat(target, function(err, stats) {
        var e, error, fail;
        fail = function(err) {
          if (options.retain) {
            return notifyWhenExists(target, function() {
              emitter.emit('create', target);
              return watchTarget();
            });
          } else {
            return emitter.emit('failure', target, err);
          }
        };
        if (err) {
          return fail(err);
        }
        emitter.targets[target].stats = stats;
        try {
          if (stats.isDirectory()) {
            fswatcher = watchTargetDir();
            if (options.include || options.recurse) {
              scanTargetDir(true);
            }
          } else {
            fswatcher = watchTargetFile();
          }
        } catch (error) {
          e = error;
          return fail(e);
        }
        emitter.emit('success', target);
        return fswatcher.on('error', function(err) {
          throw err;
        });
      });
    })();
    retainTarget = watchTarget;
    unwatchTarget = function() {
      fswatcher.close();
      return delete emitter.targets[target];
    };
    watchTargetFile = function() {
      return fs.watch(target, {
        persistent: options.persistent
      }, function(event) {
        if (event === 'rename') {
          return fs.stat(target, function(err) {
            if (err) {
              unwatchTarget();
              if (options.retain) {
                retainTarget();
              }
              return emitter.emit('unlink', target);
            } else {
              return emitter.emit('change', target);
            }
          });
        } else if (event === 'change') {
          if (options.debounce) {
            return conditionalTimeout(target, 1000, function() {
              return fs.stat(target, function(err, stats) {
                var prevStats;
                if (err || !(target in emitter.targets)) {
                  return;
                }
                prevStats = emitter.targets[target].stats;
                if (stats.mtime.getTime() === prevStats.mtime.getTime()) {
                  return;
                }
                emitter.targets[target].stats = stats;
                return emitter.emit('change', target);
              });
            });
          } else {
            return emitter.emit('change', target);
          }
        }
      });
    };
    watchTargetDir = function() {
      return fs.watch(target, {
        persistent: options.persistent
      }, function(event, filename) {
        if (event === 'rename') {
          return fs.stat(target, function(err) {
            if (err) {
              unwatchTarget();
              if (options.retain) {
                retainTarget();
              }
              return emitter.emit('unlink', target);
            } else {
              if (!options.include) {
                emitter.emit('rename', target);
              }
              if (options.include || options.recurse) {
                return scanTargetDir();
              }
            }
          });
        }
      });
    };
    scanTargetDir = function(initial) {
      return fs.readdir(target, function(err, items) {
        var i, item, len, results;
        if (err) {
          return;
        }
        results = [];
        for (i = 0, len = items.length; i < len; i++) {
          item = items[i];
          results.push((function(item) {
            var itemPath;
            if (ignored(item)) {
              return;
            }
            itemPath = path.join(target, item);
            return fs.stat(itemPath, function(err, stats) {
              var isDir;
              if (err) {
                return;
              }
              isDir = stats.isDirectory();
              if ((isDir && options.recurse) || (!isDir && options.include)) {
                if (watchit(itemPath, extend({
                  emitter: emitter
                }, options))) {
                  if (!initial) {
                    return emitter.emit('create', itemPath);
                  }
                }
              }
            });
          })(item));
        }
        return results;
      });
    };
    return emitter;
  };

  WatchitEmitter = (function(superClass) {
    extend1(WatchitEmitter, superClass);

    function WatchitEmitter(callback1) {
      this.callback = callback1;
    }

    WatchitEmitter.prototype.emit = function() {
      var etc, event, filename;
      event = arguments[0], filename = arguments[1], etc = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      if (event === 'newListener') {
        return;
      }
      WatchitEmitter.__super__.emit.apply(this, [event, filename].concat(slice.call(etc)));
      WatchitEmitter.__super__.emit.apply(this, ['all', event, filename].concat(slice.call(etc)));
      return typeof this.callback === "function" ? this.callback.apply(this, [event, filename].concat(slice.call(etc))) : void 0;
    };

    return WatchitEmitter;

  })(EventEmitter);

  extend = function() {
    var i, len, obj, prop, source, sources;
    obj = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    for (i = 0, len = sources.length; i < len; i++) {
      source = sources[i];
      for (prop in source) {
        if (prop in source) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  pendingTimeouts = {};

  conditionalTimeout = function(key, time, callback) {
    if (key in pendingTimeouts) {
      return;
    }
    pendingTimeouts[key] = 1;
    return setTimeout((function() {
      delete pendingTimeouts[key];
      return callback();
    }), time);
  };

  notifyWhenExists = function(target, callback) {
    var levelUp, parentDir;
    if (!callback) {
      throw new Error('notifyWhenExists requires a callback');
    }
    parentDir = path.join(target, '..');
    levelUp = function() {
      return notifyWhenExists(parentDir, function() {
        return notifyWhenExists(target, callback);
      });
    };
    return fs.exists(target, function(exists) {
      var e, error, fswatcher;
      if (exists) {
        return callback();
      }
      try {
        return fswatcher = fs.watch(parentDir, {
          persistent: options.persistent
        }, function() {
          fs.readdir(parentDir, function(err, items) {
            var i, item, len;
            if (err) {
              fswatcher.close();
              levelUp();
              return;
            }
            for (i = 0, len = items.length; i < len; i++) {
              item = items[i];
              if (path.join(parentDir, item) === target) {
                fswatcher.close();
                return callback();
              }
            }
          });
        });
      } catch (error) {
        e = error;
        return levelUp();
      }
    });
  };

  module.exports = watchit;

  module.exports.conditionalTimeout = conditionalTimeout;

  module.exports.notifyWhenExists = notifyWhenExists;

}).call(this);
